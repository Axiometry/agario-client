import org.gradle.plugins.ide.eclipse.model.ProjectDependency
import org.gradle.plugins.ide.eclipse.model.SourceFolder


description = 'Scala Agario Client'
group = 'me.axiometry.agario'
version = '0.0.1'

apply plugin: 'scala'
apply plugin: 'eclipse'
apply plugin: 'idea'

compileJava {
	sourceCompatibility = 1.8
	targetCompatibility = 1.8
}
compileScala {
	sourceCompatibility = 1.8
	targetCompatibility = 1.8
}

repositories {
	mavenCentral()
	mavenLocal()
}

dependencies {
	compile('org.scala-lang:scala-library:2.11.4')
	
	// Scopt
	compile('com.github.scopt:scopt_2.11:3.2.0')
	
	// Akka
	compile('com.typesafe.akka:akka-actor_2.11:2.3.10')
	
	// Spray
	compile('com.wandoulabs.akka:spray-websocket_2.11:0.1.4')
	compile('io.spray:spray-client_2.11:1.3.2')
	
	// SLF4J
	compile('org.clapper:grizzled-slf4j_2.11:1.0.2')
	compile('org.slf4j:slf4j-simple:1.7.7')
	
	// Test
	testCompile('org.scalatest:scalatest_2.11:2.2.0')
	testCompile('org.scalamock:scalamock-scalatest-support_2.11:3.1.4')
}


task spec(dependsOn: ['testClasses'], type: JavaExec) {
	main = 'org.scalatest.tools.Runner'
	args = ['-R', 'build/classes/test', '-o']
	classpath = sourceSets.test.runtimeClasspath
}
tasks.test.dependsOn += tasks.spec

task pack(type: Jar) {
	manifest {
		attributes 'Implementation-Title': project.name,
				   'Implementation-Version': project.version
	}
	baseName = project.name + '-all'
	from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
	with jar
}
tasks.assemble.dependsOn(pack)


eclipse {
	classpath {
		downloadSources = true
		
		// Prevent addition of duplicate JREs to classpath
		def hasContainer = true
		containers.clear()
		file.beforeMerged { classpath ->
			if(!classpath.entries.find { entry -> entry.kind == 'con' }) {
				containers.add('org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8')
				hasContainer = false
			}
		}
		file.whenMerged { classpath ->
			if(!hasContainer)
				classpath.entries.findAll { entry -> entry.kind == 'con' }*.exported = false
		}
		
		// Replace classpath entries with project dependencies (GRADLE-1116)
		// http://issues.gradle.org/browse/GRADLE-1116
		file.whenMerged { classpath ->
			def regexp = /.*?\/([^\/]+)\/build\/[^\/]+\/(?:main|test)/
			def projectOutputDependencies = classpath.entries.findAll { entry -> entry.path =~ regexp }
			projectOutputDependencies.each { entry ->
				def matcher = (entry.path =~ regexp)
				if (matcher) {
					def projectName = matcher[0][1]
					def path = "/${projectName}"
					if(!classpath.entries.find { e -> e instanceof ProjectDependency && e.path == path }) {
						def dependency = new ProjectDependency(path, project(":${projectName}").path)
						dependency.exported = true
						classpath.entries.add(dependency)
					}
					classpath.entries.remove(entry)
				}
			}
			classpath.entries.removeAll { entry -> (entry.path =~ /(?!.*?repack.*\.jar).*?\/([^\/]+)\/build\/libs\/[^\/]+\.jar/) }
		}
		
		// Use separate main/test outputs
		defaultOutputDir = file(project.name + "/bin/eclipse")
		file.beforeMerged { classpath ->
			classpath.entries.findAll{ it instanceof SourceFolder }.each {
				if(it.output != null && it.output.startsWith("bin/")) {
					it.output = null
				}
			}
		}
		file.whenMerged { classpath ->
			classpath.entries.findAll{ it instanceof SourceFolder }.each {
				it.output = "bin/" + it.path.split("/")[1]
			}
		}
		
		// Ensure project dependencies come after 3rd-party libs
		eclipse.classpath.file.whenMerged { classpath ->
			classpath.entries.findAll { it instanceof ProjectDependency }.each {
				// delete from original position
				classpath.entries.remove(it)
				// append to end of classpath
				classpath.entries.add(it)
			}
		}
	}
}
